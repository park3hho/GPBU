# 1주차 1교시: Data Structure 개요
> **목차**
>- 알고리즘  
>- 추상데이터 타입
>- 복잡도 분석

## A1. 알고리즘
### (1) 일상생활에서 자료구조 이해
- **스택**: 그릇을 쌓아 보관하는 것 
- **큐**: 마트 곗나대 줄
- **버킷리스트**: 리스트
- **사전(정렬)**: 영어사전
- **그래프**: 지도
- **트리**: 컴퓨터의 디렉토리 구조

프로그램은 자료구조와 알고리즘의 ***결합*** &rarr; `프로그램 = 자료구조 + 알고리즘`

### (2) 자료구조와 알고리즘
#### ㄱ. 알고리즘의 조건
- 명백성: 명령어의 의미가 명확해야함.
- 유한성: 종료되어야 함.
- 유효성: 실행 가능한 연산이어야 함.

**알고리즘의 개념**: 어떠한 문제를 해결하기 위한 단계적인 절차.

#### ㄴ. 알고리즘의 기술 방법
**자연어** &rarr; `단점`: 명백성에 위협됨.  
**흐름도** &rarr; `단점`: 복잡해짐  
**의사코드** = 유사코드: &rarr;   
**프로그래밍 언어** &rarr; 

## B2. 추상 데이터 타입
### (1) 자료형
개념: 데이터의 종류
- `데이터`의 집합과 `연산`의 집합을 말함
- 정수, 실수, 문자열 등이 기초적인 자료형

#### ㄱ. 자료형의 구분
기초 자료형, 
- `CHAR`, `INT` ...

파생 자료형,
- 배열
- 포인터

사용자정의 자료형
- 구조체
- 공용체
- 열거형

### (2) 추상 데이터 타입 (ADT)
#### ㄱ. 추상 데이터 타입의 개념
- ADT(Abstract Data Type)
- 데이터 타입을 추상적(수학적)으로 정의한 것임
- 데이터, 연산이 무엇(what)인가는 정의되지만 어떻게(How) 구현할 것인지는 정의되지 않음.

추상화 &rarr; 정보은닉기법 &rarr; 추상자료형

**추상화란?** 중요 정보만 강조하고 세부 정보는 드러내지 않는 것.  
추산 데이터 타입의 **연산**: `인터페이스` 역할을 함.

예시: TV, GUI 등등

## C3. 복잡도 분석
### (1) 알고리즘의 성능 분석

수행시간 측정
- 실제 실행 시간을 측정함.
- 특징: 하드웨어 성능의 영향을 받음

알고리즘의 성능 분석
- **연산의 횟수**를 측정하여 비교
- 특징: 하드웨어 성능의 영향을 받지 않음.

### (2) 성능 측정 방법
#### ㄱ. 수행시간 측정 방법
**방법1.** | C 언어 기준  
`clock()`: 클럭 이용하여 시간 계산

**방법2.**  
`time(NULL)`: 시간으로 계산 

### (3) 시간 복잡도
**정의**: 알고리즘을 이루고 있는 연산들이 몇 번이나 수행되는지를 0숫자로 표시한 것  
**종류**: (1)시간 복잡도; (2)공간 복잡도

#### ㄱ. 복잡도 고려사항
1. 입력 개수 고려
2. 연산 구현의 비용 고려

#### ㄴ. 표기법: Big O 표기법
차수가 가장 큰 항이 가장 영향을 미친다. 
- 연산의 횟수를 **점근적**으로 표기함.

상수형: O(1)  
로그형: O(logN)  
선형: O(N)  
선형로그형: O(nlogN)  
2차형: $n^2$  
3차형: $n^3$  
지수형: $2^n$  
팩토리얼형: 2!  

빅 오메가 표기법: 함수의 **하한**을 표시함.
$\\Omega$  
빅 세타 표기법: 함수의 상환과 하한을 동시에 표시함.
$\\Seta$

#### ㄷ. 알고리즘 수행시간의 비교
알고리즘의 수행시간은 **입력 자료 집합**에 따라 다를 수 있음.

1. Best Case
2. Average Case
3. Worst Case

Worst Case를 가장 많이 씀

---

# 1주차 2교시: 순환

## D4. 순환 (Recursion)
- **정의**: 알고리즘, 함수가 수행 중에 자기 자신을 다시 호출하여 문제를 해결하는 기법(재귀 호출)
- 정의 자체가 순환적으로 되어 있는 경우가 적합함.
- 종료 조건이 중요함.

## E5. 팩토리얼
### 팩토리얼 알고리즘
**n!**
```Code
int factorial(int n)
  {
  if(n <= 1) return 1;
  else return n*factorial(n-1);
};
```
```DeCode
n = 5;
factorial(5)
=5*factorial(4)
=5*4*factorial(3)
=5*4*3*factorial(2)
=5*4*3*2*factorial(1)
```
### 거듭제곱 알고리즘
$X^n$  
**거듭제곱 값 프로그래밍  
숫자 x의 n 제곱 값을 구하는 문제**
- 반복
```반복 Code
double slow_power(double x, int n)
  {
  int i;
  double result = 1.0;
  for(i=0; i<n; i++)
    result = result * x;
  return(result)
}
```
```반복 DeCode
X*X*X*X ...
==================
시간 복잡도 O(logn)
```
- 순환
```순환 Code
double power(dobule x, int n)
{
    if(n==0) return 1;
    else if ((n%2)==0)
        return power(x*x, n/2);
    else return x*power(x*x, (n-1)/2);
}
```
```순환 DeCode
x = 2, n = 5;
x=2x2x2, n=2;
x=(2x2x2)x2, n=1;
===============
시간 복잡도 O(n)
```

## F6. 피보나치
### (1) 피보나치 알고리즘
$F_n = F_{n-1} + F_{n-2}$
- 반복
```Code
int fib_iter(int n)
{  
    if (n==0) return 0
    if (n==1) return 1
    
    int pp = 0;
    int p = 1;
    int result = 0;
    
    for (int i=2; i<=n; i++){
        result = p + pp
        pp = p;
        p = result;
        }
    return result;
}
```
```Decode
n=3;

result = 0 + 1;
result = 1 + 1;
result = 2 + 1;
```

## G7. 하노이탑
### (1) 스택 구조
```
void hanoi_tower(int n, char from, char tmp, char to)
{
    if(n==1){
        printf("%원판 1을 c에서 %c로 원판을 옮긴다." \n, from, to)
    }
    else{
        hnoi_tower(n-1, from, to, tmp);
        printf("%원판 %d을 c에서 %c로 원판을 옮긴다." \n, n, from, to);
        hanoi_tower(n-1, tmp, from, to);
    }
}
int main(void){
    hanoi_tower(3, 'A', 'B', 'C')
    return 0
}    
```
```yaml
호출 순서:
hanoi_tower(3)
hanoi_tower(2)
hanoi_tower(1)

실행 순서:
hanoi_tower(1)
hanoi_tower(2)
hanoi_tower(3)
```
