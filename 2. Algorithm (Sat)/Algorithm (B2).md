# 2주차 1교시: 자료구조
## F6. 자료구조의 종류와 특징
정의: 컴퓨터 과학에서 효율적인 접근 및 수정을 효과적으로 하기 위한 자료의 조직, 관리, 저장
- 데이터 값의 모임, 데이터간의 관계, 데이터에 적용할 수 있는 함수나 명령을 의미
- **메모리**를 효율적으로 사용하기 위해 데이터에 맞는 자료구조의 선택이 중요
- 프로그램 설계 시 가장 먼저 고려되어야 함
- 프로그램 성능에 직접적인 영향을 미침

### (1) 자료구조의 종류
물리적 자료구조: 메모리에 실제로 어떻게 저장될 것인지 구조화된 것 

- **ㄱ. 단순구조** 
  - 정수
  - 실수
  - 문자
  - 문자열
- **ㄴ. 선형구조**
  - 순차 리스트
  - 연결 리스트
    - 단순 연결 리스트
    - 이중 연결 리스트
    - 원형 연결 리스트
  - 스택
  - 큐
  - 덱
- **ㄷ. 비선형 구조** 
  - 트리
    - 일반 트리
    - 이진 트리
  - 그래프
    - 방향 그래프
    - 무방향 그래프  
- **ㄹ. 파일 구조**
  - 순차파일
  - 색인파일
  - 직접파일

### (2) 선형구조와 비선형구조의 정확한 구분
- i 번째 값을 탐색한 뒤에 i+1의 값이 정해지지 않은 구조

### (3) 파일 저장을 위한 자료구조
- 파일구조
  - 순차파일
  - 색인파일
  - 직접파일

### (4) 기본 자료구조
#### ㄱ. **배열(Array)**
물리적 자료구조
- 각 원소들이 모두 같은 데이터 타입을 가짐
- 각 원소의 물리적 순서가 논리적 순서와 동일함
- 첫번째 원소의 메모리 주소로 다른 원소의 주소로 계산할 수 있음
- 인덱스를 통한 직접 접근함
  - 어디로 접근하든 접근시간은 동일
- 삽입/삭제 시 많은 양의 데이터 이동이 필요함.

#### ㄴ. 연결 리스트 (Linked List)
- 물리적인 공간에 연속적으로 저장되어 있는 것이 아닌, 흩어져 있는 데이터 간의 주소를 저장하여 찾음.
특징
- 데이터와 링크를 갖는 노드로 구성됨
- 논리적 순서와 물리적 순서가 동일하지 않음
- 데이터 삽입/삭제가 쉬움
- 연결 리스트의 종류
  - 단순 연결 리스트
  - 이중 연결 리스트
  - 원형 연결 리스트

#### ㄷ. 스택(Stack)
규칙이 있기 때문에 여기서부턴, 알고리즘이라고 불림.
- 삽입/삭제가 한쪽에서만 발생
- LIFO 

**스택의 구조**
- 용량
- 최상의 노드의 위치
- 노드 배열
```yaml
Typedef struct 스택_배열
{
  int 용량;
  int 최상;
  Node* 노드;
}
```
**스택의 구조체**
- 헤드노드의 위치
- 최상의 노드의 위치
```
{ // 최상위 노드의 위치 인덱스가 필요 없음
    Node* 리스트;
    Node* 최상위;
}
```

#### ㄹ. 큐(Queue)
- FIFO
- 데이터가 빠지면 그 자리를 채워야함.
  - 매번 그렇게 채우면 비효율적이기 때문에, 순환 큐(출구,입구 포인터를 옮김)로 구현함.

큐의 구조체
- 용량
- 전단위치
- 후단위치
- 순환 큐 요소 배열에 대한 포인터

```yaml
Typedef struct 순환 큐_배열
  {
    int 용량; // 크기
    int 전단; // 전단의 인덱스
    int 후단; // 후단의 인덱스
    Node* 노드 // 저장소에 할당한 배열의 첫번째 요소
  }
```
```yaml
Typedef struct 순환 큐_연결리스트
  {
  node* Front; // 큐의 시작을 가르킴
  node* Rear; // 큐의 끝을 가르킴
  int count // 노드의 수
}
```

#### ㅁ. 그래프와 트리
- Node와 Edge로 표현
- 트리의 종류
  - 이진 트리
  - 균형 트리
- 그래프의 한 종류

**용어:**  
(1) 근노드 &rlarr; 가지노드(branch) &rlarr; 잎노드  
(2) 깊이(depth): 근노드에서 잎 노드까지의 간선 개수  
(3) 차수(degree): 자기가 가지고 있는 자식의 수

> 저장될 때는 배열이나 연결 리스트로 저장 됨. 어떻게 찾을 것인가라서 그럼.

- 배열로 구현한 트리
  - 1차원 배열에 자신의 부모 노드만 저장하는 방법
    - 하나의 배열에 같은 level의 노드만 저장
  - 이진 트리의 경우, 2차원 배열에서 자식 노드를 저장하는 방법
    - 이진 트리는 각 노드가 최대 2개의 자식을 갖는 트리
      - A[i][0] &rlarr; A[i][1]

**연결 리스트로 구현한 트리**
- 이진 트리의 구조체
  - 왼쪽 자식을 가리키는 포인터
  - 오른쪽 자식을 가리키는 포인터
  - 저장 데이터 형식
```
Typedef struct 트리_연결 리스트
  {
  SBTNode* 왼쪽 // 왼쪽 자식
  SBTNode* 오른쪽 // 오른쪽 자식
  char data // 저장 데이터
} 트리_연결 리스트
```

## G6. 자료구조의 알고리즘 적용
> 알고리즘의 특징에 따라 자료구조를 선택
- 효율적인 알고리즘을 위해 자료구조의 선택이 중요

---
# 2주차 2교시: 알고리즘 소개
## H7. 유용한 알고리즘 4가지
### (1) 정렬알고리즘
정의: 컴퓨터 과학과 수학에서 원소들을 번호순이나 사전 순서와 같이 일정한 순서로 열거하는 알고리즘
- 정렬은 항목들을 체계적으로 정리하는 과정
- 2가지의 서로 다른 의미의 특성이 있음
  - 순서를 정하는 것
  - 분류하는 것

> 효율적인 정렬은 탐색, 병합처럼 다른 알고리즘을 최적화하는 데 중요함

### (2) 탐색 알고리즘
정의: 데이터를 효율적으로 찾기 위한 알고리즘
- 탐색 알고리즘의 종류에 따라 배열과 연결 리스트 모두에 사용할 수 있고 어떤 알고리즘은 배열 또는 연결 리스트 또는 트리에만 사용이 가능함
  - 순차탐색, 이진탐색, 레드 블랙트리 알고리즘 등등

### (3) 그래프 
정의: 17세기 수학자 오일러가 개발한 이래, 수많은 분야에서 도구로 사용
- 버스노선 정리, 건축회사의 시공 일정 계획을 할 때, 내비게이션 경로를 탐색할 때 등 그래프의 응요 분야는 다양함
- 그래프는 정점과 간선의 결합이고, 정점에 대한 표현은 배열이나 연결리스트, 어떤 자료구조를 사용하더라도 쉽게 표현이 가능함
- 간선에 대한 표현을 인접한 관계로 표현함
  - 그래프 알고리즘의 순회방법인깊이우선 순회와 너비우선 순회, 프림 알고리즘, 크러스컬 알고리즘, 다익스트라 알고리즘 등등

### (4) 문자열 검색 알고리즘
정의: 문자열 자체가 아닌 문자열 안에 존재하는 특정 단어를 빠르게 찾아내기 위한 알고리즘
- 문자열검색은 많은 응용프로그램에서 사용하고 있는 활용도가 높은 알고리즘임
  - 카프-라빈 알고리즘, KMP 알고리즘, 보이어-무어 알고리즘 등등

## I8. 문제 해결 방식에 따른 알고리즘 3가지
### (1) 분할정복 알고리즘
정의: 주어진 문제의 입력을 분할하여 문제를 해결하는 방식의 알고리즘
- 분할된 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산하여, 이들의 해를 취합하여 원래의 문제의 해를 얻는 방법의 알고리즘
- 분할된 입력에 대한 문제를 '부분문제'라고 하고, 부분문제의 해를 '부분해'라고 함
- 부분문제는 더 이상 분해할 수 없을 때까지 계속 분할함
  - 분할정복 알고리즘 방법을 이용한 정렬 알고리즘인 합병정렬, 퀵정렬을 알아봄
  - 선택문제와 최근 접점의 쌍 찾는 문제를 분할정복 방법을 이용하여 해결하는 알고리즘을 알아봄

### (2) 그리디 알고리즘
정의: 최적화 문제를 해결하는 알고리즘
- 최적화 문제
  - 가능한 해들 중에서 가장 좋은 해를 찾는 문제
- 그리디 알고리즘은 욕심쟁이 방법, 탐욕적 방법, 탐욕 알고리즘 등으로 불림
- 그리디 알고리즘은 입력 데이터 간의 관계를 고려하지 않고 수행과정에서 욕심내여 최소값 또는 최대값을 가진 데이터를 선택하는 알고리즘

특징: 그리디 알고리즘은 매우 단순하며, 문제에 제한적으로 적용하고 해결함.
- 동전 거스름돈 문제, 최단경로 찾기 문제, 부분배낭 문제, 집합커버 문제, 작업 스케쥴링 문제를 통해 그리디 알고리즘의 동작을 알아봄

### (3) 동적 계획 알고리즘
정의: 최적화 문제를 해결하는 알고리즘으로 동적 프로그래밍이라고 함.
- 동적계획 알고리즘은 입력 크기가 작은 부분문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분문제들을 해결하여 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘
- 동적계획 알고리즘에는 부분 문제들 사이에 의존적 관계가 있으며 부분해를 중복하지 않음.

> 피보나치 수열을 찾을 때 재귀호출 방법을 사용하는 것과 동적계획 알고리즘을 사용하는 것을 비교 설명함
- 모든 쌍 최단경로 문제를 동적계획 알고리즘으로 해결한 플로이드-워셜 알고리즘과 연속 행렬 곱셈문제를 동적계획 알고리즘으로 해결하는 방법을 알아봄.
- 편집거리 문제, 배낭문제, 동전 거스름돈 문제를 동적계획 알고리즘으로 해결해 보고, 그리디 알고리즘과 비교해 봄.

## J9. 인공지능 알고리즘
### (1) 근사 알고리즘
> NP-완전 문제를 해결하고자 할 때 다음과 같은 3가지를 충족시켜야 함
- 다항식 시간에 해를 찾을 것
- 모든 입력에 대해 해를 찾는 것
- 최적해를 찾는 것

근사 알고리즘의 정의: 최적해를 찾는 것을 포기하고 다항식 시간에 모든 입력에 대해 해를 찾는 알고리즘
- 근사 알고리즘은 최적해 대신 근사해를 찾으므로 근사 비율과 함께 결과를 제시해야함
  - 여행자 문제, 정점커버문제, 통 채우기 문제, 작업 스케쥴링 문제를 해결하는 근사 알고리즘을 알아봄.


### (2) 해 탐색 알고리즘
- 백트레킹 기법, 분기 한정 기법, 모의 담금질 기법

### (3) 학습 알고리즘
정의: 기계학습, 머신러닝이라고 부름
- 학습 알고리즘은 경험을 통해 자동으로 개선하는 컴퓨터 알고리즘의 연구임
- 인공지는의 한 분야
- 지도 학습, 비지도 학습, 강화학습 등이 있음
  - 대표 알고리즘인 인공 신경망 알고리즘을 알아봄.