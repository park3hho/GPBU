# 2주차 1교시: 데이터베이스 저장 및 내부적 접근과정
## J9. 디스크 접근 시간 및 데이터베이스 내부적 접근과정
### (1) 최신 물리적 저장 매체
#### ㄱ. 플래시 메모리
- 메모리 칩 안에 정보를 유지시키는데에 전략이 필요 없는 비휘발성 메모리
- 읽기 속도가 쓰기 속도에 비해 빠르며 하드 디스크보다 충격에 강함.

#### ㄴ. SSD(Solid State Drive)
- 반도체를 이용하여 정보를 저장하는 장치
- 하드디스크 드라이브에 비해 속도가 빠르고 기계적 지연이나 실패율, 발열 소음도 적으며, 소형과 경량화 할 수  있는 장점이 있음
- 비싸고 수명이 짧은 것이 단점.

### (2) 디스크 접근 시간, Access Time
#### ㄱ. 저장 구조
디스크 팩은 몇개의 디스크 원반으로 구성되고 각 원반에는 여러개의 동심원이 있으며 이곳에 데이터를 저장
#### ㄴ. 실린더
디스크 팩에 있는 트랙들 가운데 지름이 같은 트랙들
#### ㄷ. 판독/기록 헤드
디스크에 저장된 데이터를 실제로 판독하고 기록하는 물리적 장치

#### ㄹ. 접근 시간 
**정의**: 헤드가 임의의 장소에서 원하느 트랙에 있는 레코드를 찾아 메인 메모리의 버퍼로 데이터를 전송하는 데걸리는 시간
- 탐색 시간 + 회전 지연 시간 + 데이터 전송 시간  

**탐색시간**: 판독/기록 헤드가 판독이나 기록할 데이터가 있는 트랙(실린더)까지 이동하는데 걸리는 시간
**회전 지연 시간**: 해당 트랙에서 원하는 레코드(섹터, 블록)가 회전하여 헤드 밑에까지 오기를 기다리는 시간
**데이터 전송 시간**: 디스크 블록을 메모리로 전송하는 데 걸리는 시간으로 데이터 전송 시간은 전송 용량에 비례

- 디스크 접근 시간은 메인 메모리 접근시간에 비해 매우 느림
- I/O 횟수가 DBMS의 성능을 결정하는 중요한 요소

### (3) 데이터베이스 내부적 접근 과정
사용자 &rarr; DBMS &rarr; 파일 관리자 &rarr; 디스크 관리자 &rarr; 저장 데이터베이스

#### ㄱ. 디스크 관리자의 기능
- 운영체제의 한 구성요소로서 모든 물리적 입출력(I/O) 연산에 대한 책임을 진다.
- 페이지 관리 기능을 함.
- 디스크 디렉터리는 디스크에 있는 모든 페이지 세트의 리스트와 각 페이지 세트의 첫번째 페이지에 대한 포인터 저장

#### ㄴ. 파일 관리자 기능
- 저장 레코드 관리
- 저장 레코드는 레코드 ID(RID)로 식별
- RID는 전체 디스크 냉서 유일하며 페이지 번호와 페이지 오프셋으로 구성
  - RID = (페이지 번호 p, 오프셋)

#### ㄷ. 클러스터링(Clustering)
- 지정된 컬럼 값의 순서대로 실제 메모리에 테이블의 데이터를 저장시키는 액세스의 효율성을 높이기 위하여 사용되는 물리적인 저장 기법
- Cluster 키는 기본 키와는 독립적임
  - 보통 성능향상을 목적으로 함
- 클러스터 된 레코드에 대한 임의 접근(Random Access)가 빨라짐
- 전체 테이블 스캔 속도는 느려짐

- 다량의 범위 데이터에 대한 검색을 자주하는 경우
- 넓은 분포도를 가지고 있어 인덱스 활용이 어려운 경우
- 수정이 자주 발생하지 않는 Column 또는 반복 Column이 분할되는 경우

## K10. RAID의 개념 및 종류
### (1) RAID의 개념
여러 개의 하드 디스크를 하나의 Virtual Disk로 구성하여 대용량 저장장치로 사용
- 여러 개의 하드 디스크에 데이터를 분할, 저장
  - 전송속도의 향상 및 시스템 가동 중 생길 수 있는 하드 디스크의 에러를 시스템 정지 없이 교체함으로써 데이터 자동복구 수행

### (2) RAID의 레벨
#### ㄱ. RAID 0 (Striping)
- 데이터의 빠른 입-출력이 가능하도록 여러개의 하드 디스크에 분산되어 저장
  - 하나의 디스크에 저장하는 데 8분이 소요되는 데이터를 4개의 데스크에 동시 분산하여 저장하면 2분만에 저장 완료.

#### ㄴ. RAID 1 (Mirroring)
- 단순히 한 드라이브에 기록되는 모든 데이터를 다른 드라이브에 복사하는 방식

#### ㄷ. RAID 2 (Hamming for Error Correction)
- RAID 0처럼 스트라이핑 방식
- Hamming Code 씀, Raid 4가 나오며 쓰지 않음

#### ㄹ. RAID 3
- Parallel transfer with parity, Dedicated Parity
- Striping 구성에 추가로 에러 체크 및 수정을 위해서 Parity 정보를 별도의 디스크에 따로 저장.
- byte 단위로 디스크에 나누어 저장

#### ㅁ. RAID 4
- 대형 스트라이프 사용
- 데이터를 블록 단위로 나눠 기록하며 RAID 3과 같은 방식

#### ㅁ. RAID 5
- Independent data disks with distributed parity blocks
- 가장 널리 사용되고 있는 방식
- 3-4의 단점(Parity Drive의 병목현상)을 개선한 것
- 별도 Parity Drive가 아닌 나누어 저장함

#### ㅂ. RAID 6
- P + Q Redundancy scheme, Distributed Parity
- 이중으로 Parity를 넣음

#### ㄹ. RAID 1 + 0 / -0 + 1
- 0 + 1은 RAID 0을 미러링 하는 것
- 1 + 0은 RAID 1을 미러링 하는 것

## L11. 파일 설계
### (1) 파일 설계 개요
기본 요소  
필드 &rarr; 레코드 &rarr; 파일 &rarr; 데이터베이스

#### ㄱ. 데이터베이스의 거주 장소
- 저장 공간의 방대성 
- 비휘발성
- 접근 시간의 비효율성

#### ㄴ. 처리 절차
1. Find the Location of Data  
2. Read and Move Data to Buffer  
3. Process  
4. Write Back  

#### ㄷ. 블록킹의 필요성
- 디스크 접근 횟수를 줄이기 위함
  - 레코드 단위로 저장하면 I/O 횟수가 많아짐
- 파일 크기를 고려하여 트랙을 블록 단위로 나눔
- 데이터 접근 최소 단위는 블록

#### ㄹ. 블록킹 인수, Blocking Factor: BFR
- 한 블록에 저장되는 레코드들의 개수
- 디스크 IO를 줄이지만, 버퍼 크기만큼 Main Memory의 비효율성을 야기함

