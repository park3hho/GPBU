# 3주차 1교시: 프로세스
## I9. 프로세스 상태 변환
### (1) 프로세스의 개념
- 1960년대 멀틱스 시스템(Multix System) 설계자 처음 사용, 이후 Task(작업)이란 용어와 함께 사용되며 다양한 정의를 가짐

**정의**: 실행 중인 프로그램
- 디스크에 저장되어 있던 실행 가능한 프로그램이 메모리에 적재되어 운영체제의 제어를 받는 상태
- 해당 프로세스가 사용하고 있는 메모리 영역이 존재함을 의미
- 프로세서 할당 시간과 메모리, 파일, 입출력장치 등의 자원이 필요하며, 자원은 프로세스 생성 및 실행 시 할당됨
- 현재의 할동 상태를 나타내는 프로그램 카운터와 프로세서의 현재 활동 포함.

**실행 스택(Stack &rarr; Heap &rarr; 정적 변수 &rarr; Code)**
- 프로그램과 달리 프로세서는 메모리에 주소 공간을 갖는 능동적인 개체

#### ㄱ. 스택 구조
- **실행 스택**: 호출된 프로시저(함수)의 복귀 주소와 지역 변수 등의 일시적인 데이터를 저장하는 영역
- **실행 힙**: 텍스트(코드) 영역과는 별도로 유지되는 자유 영역
- **데이터(정적변수)**: 프로세스 실행 중 동적으로 할당 받는 영역, 전역 또는 정적 변수 저장
- **텍스트(코드)**: 프로세서가 실행하는 코드 저장

#### ㄴ. 재진입 프로그램(재진입 코드)
- 메모리 내에 동일한 사본을 여러 사용자가 공유할 수 있도록 작성된 프로그램 또는 루틴
- 실행 중 사용할 데이터를 보관하는 실행 스택과 공통적인 데이터를 보관하는 데이터 영역을 가짐
- 프로세서가 동일한 프로그램을 사용하여도 텍스트(코드) 영역은 같으나 별도의 스택에 서로 다른 데이터를 가지므로 별개의 프로세스로 인식됨.
- 데이터베이스 , 문서 편집기 등

**&#8251; 즉, 사용자 관점에서 세그먼트(코드, 데이터, 스택 등)의 가상 주소 공간을 갖는 상태, 시스템 관점에서 실행 중인 프로그램을 의미함.**

#### ㄷ. 처리 상태에 있는 데이터 구조로 표현 가능
- 스케줄러(디스패칭)에 의해 프로세서 할당
- 파일에 관련된 자원에 대한 참조
  - 장치 관리, 메모리 관리
- 프로세스 지원과 협력에 관한 정보 교환
  - 교착상태, 보호, 동기화
- 프로세스 관련 연산은 생성, 종료, 보류, 자원 할당, 해제

### (2) 프로세스의 종류
실행 유행에 따라 크게 세가지로 구분
#### ㄱ. 운영체제 프로세스
- 커널 프로세스 또는 시스템 프로세스라고 부름
- 프로세스 실행 순서 제어, 사용하고 있는 프로세스가 다른 사용자나 운영체제 영역을 침범하지 못하게 감시하는 기능담당
- 사용자 프로세스 생성, 입출력 프로세스 등 시스템 운영에 필요한 작업 수행

#### ㄴ. 사용자 프로세스
- 사용자 코드 수행

#### ㄷ. 병행 프로세스
- 프로세스 여러 개가 동시에 실행됨
- 독립 프로세스와 협동 프로세스로 구분

독립프로세스
- 프로세스 여러 개가 병행하여 수행 시 주어진 초기값에 따라 항상 같은 결과를 보여줘야함
- 서로 독립적으로 실행되어 다른 프로세스에 영향을 받지 않고, 데이터를 공유하지 않음

협동 프로세스
- 다른 프로세스에 영향을 주거나 다른 프로세스에 의해 영향을 받음
- 컴퓨터 시스템의 제한된 자원을 공유하는 프로세스들이 통제되어 상호작용해야 하는 경우에 발생
- 서로 협동해야하는 경우, 동기화가 필요할 수 있음.

#### ㄹ. 실행과 비실행 프로세스로 구분
- 프로세스는 실행되며 상태가 변하므로 운영체제는 프로세스 제어에 필요한 프로세스 상태를 점검해야함
- 운영체제가 프로세스를 새로 생성하면 비실행 상태로 초기화되어 실행을 기다림.

- 실행 중인 프로세스 종료 또는 인터럽트 발생 시 비실행 프로세스 중 선택된 프로세스가 실행 상태로 변함(디스패치)
- 인터럽트 된 프로세스는 비실행 상태로 변경


### (3) 프로세스의 상태
- 대부분의 프로세스는 준비나 대기(보류) 상태이며, 어느 한 순간에 한 프로세스만 실행하게 됨.  

**준비** &rarr; **실행** &rarr; **대기**

### (4) 프로그램과 프로세스
프로그램: 저장장치에 저장되어 있는 정적인 상태  
프로세스: 실행을 위해메모리에 올라온 동적인 상태  

#### ㄱ. 메모리와 프로세스
Stack &rlarr; Heap &rarr; Data, Code

### (5) 요리사 모형에 비교

## J10. 프로세스 처리 과정
### (1) 프로그램에서 프로세스로의 전환
1. A, B, C 각각의 Task(작업)가 생김
2. 각각의 프로세스에 각각의 프로세서가 할당됨

#### ㄱ. PCB, Processor Control Block
- 운영체제가 해당 프로세스를 위해 관리하는 자료 구조
- 프로세스 구분자
  - 각 프로세스를 구분하는 구분자
- 메모리 관련 정보
  - 프로세스의 메모리 위치 정보
- 각종 중간 값
  - 프로세스가 사용했던 중간 값

프로그램이 프로세스가 된다는 것  
- 운영체제로부터 프로세스 제어 블록을 얻는다는 뜻

프로세스가 종료된다는 것
- 해당 제어블록이 폐기된다는 뜻

프로세서 = 프로그램 + 프로세서 제어블록


### (2) 프로세스의 상태
생성 상태 &rarr; 준비 상태(PCB를 생성함) &rarr; 실행 상태 &rarr; 완료 상태


#### ㄱ. 프로세스의  4가지 상태
**디스패치**: 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업  
**타임아웃**: 프로세스가 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는 것

#### ㄴ. 프로세스의 5가지 상태
> **New** &rarr; **Ready** &rarr; **Running** &rarr; **Waiting** &rarr; **Terminated**

- **생성 상태**: 프로세서 블록을 할당받은 상태  
- **준비 상태**: **큐**에서 자기 순서를 기다리는 상태, PID(Distpatcher)로 처리  
  - `distpatch`
- **실행 상태**: CPU를 할당받아 처리하는 상태
  - `timeout`
  - `exit`
  - `block`
- **대기 상태**: 아직 작업이 안끝나서 다시 시작하길 기다리는 상태
  - `wakeup`
- **완료 상태**: 종료

---
# 3주차 2교시: 프로세스 제어 블록과 문맥 교환
## K11. 프로세스 제어 블록
### (1) PCB, Process Contrl Block
**정의**: 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
- 프로세스는 고유한 프로세스 제어 블록을 가짐
- 프로세스 생성 시 만들어져서 프로세스가 실행을 완료하면 폐기

### (2) 프로세스 제어블록의 구성
- 포인터 & 프로세스 상태
- 프로그램 카운터
- 프로세스 우선순위
- 각종 레지스터 정보
- 메모리 관리 정보
- 할당된 자원 정보
- 계정 정보
- PPID & CPID

**포인터:**
- 준비상태나 대기 상태의 큐를 구현할 때 사용, 주소값을 의미함  

**프로세스 상태:**
- 프로세스 상태 나타냄

**프로세스 구분자:**
- 운영 체제 내에 있는 여러 프로세스 구현하기 위한 구분자

**프로그램 카운터:** 
- 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값

**프로세스 우선순위:**
- 프로세스의 실행 순서를 결정하는 우선순위

**각종 레지스터 정보:**
- 프로세스가 실행되는 중에 사용하던 레지스터 값

**메모리 관리 정보:**
- 프로세스 메모리의 위치를 나타내는 메모리 위치 정보 (경계 레지스터 값과 한계 레지스터 값)

**할당된 자원 정보:**
- 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보

**계정 정보:**
- 제곧내

**PPID & CPID:**
- 부모 프로세서 ID와 자식 프로세서 ID

## L12. 문맥 교환
### (1) 프로세스 교환
- 실행 중인 프로세스가 인터럽트되면, 운영체제가 다른 프로세스를 실행 상태로 변경
- 해당 프로세스에 제어를 넘겨주는 과정에서 실행 중인 프로세스로부터 제어를 인수한 운영체제가 또 다른 프로세스에 제어를 넘겨주기 위해 발생

트랩은 시스템이 치명적인 오류인지를 판단
- 치명적 오류일 경우
  - 프로세스를 종료하면서 프로세스 교환 발생

### (2) 문맥 교환(Context Switching)
프로세스를 다른 프로세스로 교환하기 위해 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 일련의 과정
- 프로세스가 "준비 &rarr; 실행", "실행 &rarr; 준비", "실행 &rarr; 대기" 상태로 변할 때 발생
- 오버헤드가 발생하며 오버헤드는 메모리 속도, 레지스터 수, 특수 명령어의 존재에 따라 다르므로 시스템마다 다름

### (3) 인터럽트와 트랩
#### ㄱ. 인터럽트
정의: 현재 실행되는 프로세스와 별도로 외부에서 발생되는 여러 종류의 이벤트에 의해 발생
- 제어가 인터럽트 처리 루틴으로 넘어간 후에도 기본 시스템 관리 작업을 처리함
- 인터럽트 형태에 따라 관련된 운영체제 루틴으로 분기됨

대표적인 예
- 입출력 인터럽트
- 클록 인터럽트+

#### ㄴ. 트랩
정의: 부적적한 파일 접근 또는 현재 실행 중인 프로세스에 의해 발생되는 오류나 예외 상황으로 인해 발생

### (4) 프로세스 문맥의 구성
#### ㄱ. 사용자 수준 문맥
- 텍스트 영역
  - 프로그램 코드
- 자료 영역
  - 전역 변수
- 스택 영역
  - Run time Stack

#### ㄴ. 시스템 수준 문맥
- CPU 내의 각종 범용 및 특수 레지스터의 내용
  - PC(Program Counter) Register 포함(다음에 실행할 프로그램의 주소값을 가지고 있음)
- 프로세스의 현재의 각종 자원 사용 정보
- 기타 커널의 프로세스 관리 정보

#### ㄷ. 디스크 파일 입출력의 예
사용자 프로세스가 디스크 입력을 위한 read() 시스템 호출을 하여 완료될 때까지의 과정을 설명

- 시스템 호출 실행 및 처리
  - open(), read()-read() 실행 시 trap 발생
- 대기 상태에 의한 문맥 교환 발생
- 커널의 시스템 호출 입력의 처리
- 입력 완료 후 인터럽트 발생
- 준비 상태로의 전환
  - 커널 모드에서 사용자 모드로 전환됨

```
// 사용자 프로세스 실행
fd = open("my_file", 0)
n = read(fd, buf, 100)
```

**커널의 시스템 호출 처리 루틴**
- 커널로 디스크를 접근할 때는 `sys_`를 붙인다.

#### ㄹ. 디스크 인터럽트 처리기의 주요 기능
- 입출력이 종료된 프로세스의 PCB를 대기(Blocked) 큐에서 준비 상태로 만들어 준비(Ready) 큐로 옮김
- 준비 상태가 된 프로세스는 스케줄링을 기다리게 됨
- 일반적으로 사용자 모드에서 실행할 때보다 높은 우선순위를 할당함
- 대기 상태였던 프로세스를 일반 프로세스보다 우선실행하기 위함

디스크 제어기는 큐에 등록된 다음 입출력 정보를록을 이용해서 대기중인 다음 입출력 명령을 실행시킴
 
### (5) 프로세스의 협동, 병행 프로그래밍
**정의**: 여러 개의 협동하는 프로세스로 하나의 작업을 수행

목적
- 정보 공유: 같은 정보를 여러 사용자가 이용하는 경우
- 병렬 처리: CPU와 I/O의 중첩 처리
- 모듈성: 시스템을 여러 개의 별도 기능으로 분류하기 위함.
- 편리성: 한번에 여러 작업을 수행하는 경우
- 비동기 사건 처리: 각 사건 당 하나의 프로세서가 처리

#### ㄱ. 생산자-소비자 문제 및 프로세스
Producer Process &rarr; Circular Buffer &rarr; Consumer Process

생산자가 가져온 데이터를 버퍼에 넣어놓으면 소비자가 가져감.

**생산자 소비자 문제**
- 정의: Bounded Buffer 문제: 버퍼의 크기가 제한된 경우  
- 양쪽 프로세스의 속도 차이를 조절함  
- Buffer에 대한 동시 접근 시의 문제
  - 상호 배제: Mutual Exclusion
- 버퍼 empty, full 시의 대기/깨움 문제
  - 동기화

생산자는 버퍼가 비어있는지 지속적으로 확인함.  

소비자는 
- in 포인터: 생산자가 저장할 아이템의 위치 지정
- out 포인터: 소비자가 소비할 아이템의 위치 지정

- `in = out`의 경우 버퍼가 비어있는 상태
- `in + 1 == out` 이면 버퍼는 모두 차있는 상태


















